// Generated by Melange

import * as Caml_exceptions from "./vendor/melange.js/caml_exceptions.mjs";
import * as Caml_js_exceptions from "./vendor/melange.js/caml_js_exceptions.mjs";
import * as Curry from "./vendor/melange.js/curry.mjs";
import * as Stdlib from "./vendor/melange/stdlib.mjs";
import * as Stdlib__Buffer from "./vendor/melange/buffer.mjs";
import * as Stdlib__Format from "./vendor/melange/format.mjs";
import * as Stdlib__List from "./vendor/melange/list.mjs";
import * as Stdlib__String from "./vendor/melange/string.mjs";
import * as Stdlib__Sys from "./vendor/melange/sys.mjs";

function Make(Sexp) {
  var Parse_error = /* @__PURE__ */ Caml_exceptions.create(
    "Test.Make(Sexp).Parser.Parse_error",
  );
  var parse_error = function (msg) {
    throw {
      RE_EXN_ID: Parse_error,
      _1: msg,
      Error: new Error(),
    };
  };
  var parse_errorf = function (f) {
    return Stdlib__Format.ksprintf(parse_error, f);
  };

  var premature_end_of_input = "premature end of input";
  var create = function (param) {
    return {
      state: /* Init */ 0,
      n: 0,
    };
  };
  var int_of_digit = function (c) {
    return (c - /* '0' */ 48) | 0;
  };

  var feed = function (t, c) {
    var match = t.state;
    if (!match) {
      if (c === 41 || c === 40) {
        if (c >= 41) {
          return /* Rparen */ 2;
        } else {
          return /* Lparen */ 1;
        }
      } else if (c > 57 || c < 48) {
        return Curry._1(
          Stdlib__Format.ksprintf(
            parse_error,
            /* Format */ {
              _0: {
                TAG: /* String_literal */ 11,
                _0: "invalid character ",
                _1: {
                  TAG: /* Caml_char */ 1,
                  _0: {
                    TAG: /* String_literal */ 11,
                    _0: ", expected '(', ')' or '0'..'9'",
                    _1: /* End_of_format */ 0,
                  },
                },
              },
              _1: "invalid character %C, expected '(', ')' or '0'..'9'",
            },
          ),
          c,
        );
      } else {
        t.state = /* Parsing_length */ 1;
        t.n = (c - /* '0' */ 48) | 0;
        return /* Await */ 0;
      }
    }
    if (c >= 58) {
      if (c >= 59) {
        return Curry._1(
          Stdlib__Format.ksprintf(
            parse_error,
            /* Format */ {
              _0: {
                TAG: /* String_literal */ 11,
                _0: "invalid character ",
                _1: {
                  TAG: /* Caml_char */ 1,
                  _0: {
                    TAG: /* String_literal */ 11,
                    _0: " while parsing atom length, expected '0'..'9' or ':'",
                    _1: /* End_of_format */ 0,
                  },
                },
              },
              _1: "invalid character %C while parsing atom length, expected '0'..'9' or ':'",
            },
          ),
          c,
        );
      } else {
        t.state = /* Init */ 0;
        return /* Atom */ {
          _0: t.n,
        };
      }
    }
    if (c < 48) {
      return Curry._1(
        Stdlib__Format.ksprintf(
          parse_error,
          /* Format */ {
            _0: {
              TAG: /* String_literal */ 11,
              _0: "invalid character ",
              _1: {
                TAG: /* Caml_char */ 1,
                _0: {
                  TAG: /* String_literal */ 11,
                  _0: " while parsing atom length, expected '0'..'9' or ':'",
                  _1: /* End_of_format */ 0,
                },
              },
            },
            _1: "invalid character %C while parsing atom length, expected '0'..'9' or ':'",
          },
        ),
        c,
      );
    }
    var len = (Math.imul(t.n, 10) + ((c - /* '0' */ 48) | 0)) | 0;
    if (len > Stdlib__Sys.max_string_length) {
      throw {
        RE_EXN_ID: Parse_error,
        _1: "atom too big to represent",
        Error: new Error(),
      };
    }
    t.n = len;
    return /* Await */ 0;
  };
  var feed_eoi = function (t) {
    var match = t.state;
    if (!match) {
      return;
    }
    throw {
      RE_EXN_ID: Parse_error,
      _1: premature_end_of_input,
      Error: new Error(),
    };
  };
  var Lexer = {
    create: create,
    int_of_digit: int_of_digit,
    feed: feed,
    feed_eoi: feed_eoi,
  };
  var open_paren = function (stack) {
    return {
      TAG: /* Open */ 0,
      _0: stack,
    };
  };
  var loop = function (_acc, _param) {
    while (true) {
      var param = _param;
      var acc = _acc;
      if (typeof param === "number") {
        throw {
          RE_EXN_ID: Parse_error,
          _1: "right parenthesis without matching left parenthesis",
          Error: new Error(),
        };
      }
      if (param.TAG === /* Open */ 0) {
        return {
          TAG: /* Sexp */ 1,
          _0: {
            TAG: /* List */ 1,
            _0: acc,
          },
          _1: param._0,
        };
      }
      _param = param._1;
      _acc = {
        hd: param._0,
        tl: acc,
      };
      continue;
    }
  };
  var close_paren = function (t) {
    return loop(/* [] */ 0, t);
  };
  var loop$1 = function (_acc, _param) {
    while (true) {
      var param = _param;
      var acc = _acc;
      if (typeof param === "number") {
        return acc;
      }
      if (param.TAG === /* Open */ 0) {
        throw {
          RE_EXN_ID: Parse_error,
          _1: premature_end_of_input,
          Error: new Error(),
        };
      }
      _param = param._1;
      _acc = {
        hd: param._0,
        tl: acc,
      };
      continue;
    }
  };
  var to_list = function (t) {
    return loop$1(/* [] */ 0, t);
  };
  var add_atom = function (s, stack) {
    return {
      TAG: /* Sexp */ 1,
      _0: {
        TAG: /* Atom */ 0,
        _0: s,
      },
      _1: stack,
    };
  };
  var add_token = function (x, stack) {
    if (typeof x === "number") {
      switch (x) {
        case /* Await */ 0:
          return stack;
        case /* Lparen */ 1:
          return {
            TAG: /* Open */ 0,
            _0: stack,
          };
        case /* Rparen */ 2:
          return loop(/* [] */ 0, stack);
      }
    }
  };
  var Stack = {
    open_paren: open_paren,
    close_paren: close_paren,
    to_list: to_list,
    add_atom: add_atom,
    add_token: add_token,
  };
  var Parser = {
    Parse_error: Parse_error,
    parse_error: parse_error,
    parse_errorf: parse_errorf,
    premature_end_of_input: premature_end_of_input,
    Lexer: Lexer,
    Stack: Stack,
  };
  var feed_eoi_single = function (lexer, stack) {
    var val;
    try {
      feed_eoi(lexer);
      val = loop$1(/* [] */ 0, stack);
    } catch (raw_exn) {
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Parse_error) {
        return {
          TAG: /* Error */ 1,
          _0: exn._1,
        };
      }
      throw exn;
    }
    if (!val) {
      return {
        TAG: /* Error */ 1,
        _0: premature_end_of_input,
      };
    }
    if (val.tl) {
      throw {
        RE_EXN_ID: "Assert_failure",
        _1: ["", 213, 21],
        Error: new Error(),
      };
    }
    return {
      TAG: /* Ok */ 0,
      _0: val.hd,
    };
  };
  var feed_eoi_many = function (lexer, stack) {
    var l;
    try {
      feed_eoi(lexer);
      l = loop$1(/* [] */ 0, stack);
    } catch (raw_exn) {
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Parse_error) {
        return {
          TAG: /* Error */ 1,
          _0: exn._1,
        };
      }
      throw exn;
    }
    return {
      TAG: /* Ok */ 0,
      _0: l,
    };
  };
  var loop$2 = function (s, pos, len, lexer, stack) {
    if (pos === len) {
      var msg = feed_eoi_single(lexer, stack);
      if (msg.TAG === /* Ok */ 0) {
        return msg;
      } else {
        return {
          TAG: /* Error */ 1,
          _0: [pos, msg._0],
        };
      }
    }
    var exit = 0;
    var x;
    try {
      x = feed(lexer, s.charCodeAt(pos));
      exit = 1;
    } catch (raw_exn) {
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Parse_error) {
        return {
          TAG: /* Error */ 1,
          _0: [pos, exn._1],
        };
      }
      throw exn;
    }
    if (exit === 1) {
      if (typeof x === "number") {
        var exit$1 = 0;
        var stack$1;
        try {
          stack$1 = add_token(x, stack);
          exit$1 = 2;
        } catch (raw_exn$1) {
          var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
          if (exn$1.RE_EXN_ID === Parse_error) {
            return {
              TAG: /* Error */ 1,
              _0: [pos, exn$1._1],
            };
          }
          throw exn$1;
        }
        if (exit$1 === 2) {
          return cont(s, (pos + 1) | 0, len, lexer, stack$1);
        }
      } else {
        var atom_len = x._0;
        var exit$2 = 0;
        var atom;
        try {
          atom = Stdlib__String.sub(s, (pos + 1) | 0, atom_len);
          exit$2 = 2;
        } catch (exn$2) {
          return {
            TAG: /* Error */ 1,
            _0: [len, premature_end_of_input],
          };
        }
        if (exit$2 === 2) {
          var pos$1 = (((pos + 1) | 0) + atom_len) | 0;
          return cont(s, pos$1, len, lexer, {
            TAG: /* Sexp */ 1,
            _0: {
              TAG: /* Atom */ 0,
              _0: atom,
            },
            _1: stack,
          });
        }
      }
    }
  };
  var cont = function (s, pos, len, lexer, stack) {
    if (
      typeof stack !== "number" &&
      stack.TAG !== /* Open */ 0 &&
      typeof stack._1 === "number"
    ) {
      if (pos === len) {
        return {
          TAG: /* Ok */ 0,
          _0: stack._0,
        };
      } else {
        return {
          TAG: /* Error */ 1,
          _0: [pos, "data after canonical S-expression"],
        };
      }
    }
    return loop$2(s, pos, len, lexer, stack);
  };
  var parse_string = function (s) {
    return loop$2(
      s,
      0,
      s.length,
      {
        state: /* Init */ 0,
        n: 0,
      },
      /* Empty */ 0,
    );
  };
  var parse_string_many = function (s) {
    var _pos = 0;
    var len = s.length;
    var lexer = {
      state: /* Init */ 0,
      n: 0,
    };
    var _stack = /* Empty */ 0;
    while (true) {
      var stack = _stack;
      var pos = _pos;
      if (pos === len) {
        var msg = feed_eoi_many(lexer, stack);
        if (msg.TAG === /* Ok */ 0) {
          return msg;
        } else {
          return {
            TAG: /* Error */ 1,
            _0: [pos, msg._0],
          };
        }
      }
      var exit = 0;
      var x;
      try {
        x = feed(lexer, s.charCodeAt(pos));
        exit = 1;
      } catch (raw_exn) {
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === Parse_error) {
          return {
            TAG: /* Error */ 1,
            _0: [pos, exn._1],
          };
        }
        throw exn;
      }
      if (exit === 1) {
        if (typeof x === "number") {
          var exit$1 = 0;
          var stack$1;
          try {
            stack$1 = add_token(x, stack);
            exit$1 = 2;
          } catch (raw_exn$1) {
            var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$1.RE_EXN_ID === Parse_error) {
              return {
                TAG: /* Error */ 1,
                _0: [pos, exn$1._1],
              };
            }
            throw exn$1;
          }
          if (exit$1 === 2) {
            _stack = stack$1;
            _pos = (pos + 1) | 0;
            continue;
          }
        } else {
          var atom_len = x._0;
          var exit$2 = 0;
          var atom;
          try {
            atom = Stdlib__String.sub(s, (pos + 1) | 0, atom_len);
            exit$2 = 2;
          } catch (exn$2) {
            return {
              TAG: /* Error */ 1,
              _0: [len, premature_end_of_input],
            };
          }
          if (exit$2 === 2) {
            var pos$1 = (((pos + 1) | 0) + atom_len) | 0;
            _stack = {
              TAG: /* Sexp */ 1,
              _0: {
                TAG: /* Atom */ 0,
                _0: atom,
              },
              _1: stack,
            };
            _pos = pos$1;
            continue;
          }
        }
      }
    }
  };
  var one_token = function (ic, c, lexer, stack) {
    var n = feed(lexer, c);
    if (typeof n === "number") {
      return add_token(n, stack);
    }
    var s;
    try {
      s = Stdlib.really_input_string(ic, n._0);
    } catch (raw_exn) {
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stdlib.End_of_file) {
        throw {
          RE_EXN_ID: Parse_error,
          _1: premature_end_of_input,
          Error: new Error(),
        };
      }
      throw exn;
    }
    return {
      TAG: /* Sexp */ 1,
      _0: {
        TAG: /* Atom */ 0,
        _0: s,
      },
      _1: stack,
    };
  };
  var input_opt = function (ic) {
    var lexer = {
      state: /* Init */ 0,
      n: 0,
    };
    var c;
    try {
      c = Stdlib.input_char(ic);
    } catch (raw_exn) {
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stdlib.End_of_file) {
        return {
          TAG: /* Ok */ 0,
          _0: undefined,
        };
      }
      throw exn;
    }
    try {
      var x = feed(lexer, c);
      if (typeof x === "number") {
        var _stack = add_token(x, /* Empty */ 0);
        while (true) {
          var stack = _stack;
          var c$1 = Stdlib.input_char(ic);
          var stack$1 = one_token(ic, c$1, lexer, stack);
          if (typeof stack$1 === "number") {
            _stack = stack$1;
            continue;
          }
          if (stack$1.TAG === /* Open */ 0) {
            _stack = stack$1;
            continue;
          }
          if (typeof stack$1._1 === "number") {
            return {
              TAG: /* Ok */ 0,
              _0: stack$1._0,
            };
          }
          _stack = stack$1;
          continue;
        }
      }
      throw {
        RE_EXN_ID: "Assert_failure",
        _1: ["", 286, 24],
        Error: new Error(),
      };
    } catch (raw_exn$1) {
      var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
      if (exn$1.RE_EXN_ID === Parse_error) {
        return {
          TAG: /* Error */ 1,
          _0: exn$1._1,
        };
      }
      if (exn$1.RE_EXN_ID === Stdlib.End_of_file) {
        return {
          TAG: /* Error */ 1,
          _0: premature_end_of_input,
        };
      }
      throw exn$1;
    }
  };
  var input = function (ic) {
    var msg = input_opt(ic);
    if (msg.TAG !== /* Ok */ 0) {
      return {
        TAG: /* Error */ 1,
        _0: msg._0,
      };
    }
    var x = msg._0;
    if (x !== undefined) {
      return {
        TAG: /* Ok */ 0,
        _0: x,
      };
    } else {
      return {
        TAG: /* Error */ 1,
        _0: premature_end_of_input,
      };
    }
  };
  var input_many = function (ic) {
    try {
      var lexer = {
        state: /* Init */ 0,
        n: 0,
      };
      var _stack = /* Empty */ 0;
      while (true) {
        var stack = _stack;
        var c;
        try {
          c = Stdlib.input_char(ic);
        } catch (raw_exn) {
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.RE_EXN_ID === Stdlib.End_of_file) {
            feed_eoi(lexer);
            return {
              TAG: /* Ok */ 0,
              _0: loop$1(/* [] */ 0, stack),
            };
          }
          throw exn;
        }
        _stack = one_token(ic, c, lexer, stack);
        continue;
      }
    } catch (raw_exn$1) {
      var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
      if (exn$1.RE_EXN_ID === Parse_error) {
        return {
          TAG: /* Error */ 1,
          _0: exn$1._1,
        };
      }
      throw exn$1;
    }
  };
  var loop$3 = function (acc, t) {
    if (t.TAG !== /* Atom */ 0) {
      return (2 + Stdlib__List.fold_left(loop$3, acc, t._0)) | 0;
    }
    var len = t._0.length;
    var x = len;
    var len_len = 1;
    while (x > 9) {
      x = (x / 10) | 0;
      len_len = (len_len + 1) | 0;
    }
    return (((((acc + len_len) | 0) + 1) | 0) + len) | 0;
  };
  var serialised_length = function (t) {
    return loop$3(0, t);
  };
  var to_buffer = function (buf, sexp) {
    var loop = function (param) {
      if (param.TAG === /* Atom */ 0) {
        var str = param._0;
        Stdlib__Buffer.add_string(buf, String(str.length));
        Stdlib__Buffer.add_string(buf, ":");
        return Stdlib__Buffer.add_string(buf, str);
      }
      Stdlib__Buffer.add_char(buf, /* '(' */ 40);
      Stdlib__List.iter(loop, param._0);
      Stdlib__Buffer.add_char(buf, /* ')' */ 41);
    };
    loop(sexp);
  };
  var to_string = function (sexp) {
    var buf = Stdlib__Buffer.create(loop$3(0, sexp));
    to_buffer(buf, sexp);
    return Stdlib__Buffer.contents(buf);
  };
  var to_channel = function (oc, sexp) {
    var loop = function (param) {
      if (param.TAG === /* Atom */ 0) {
        var str = param._0;
        Stdlib.output_string(oc, String(str.length));
        Stdlib.output_char(oc, /* ':' */ 58);
        return Stdlib.output_string(oc, str);
      }
      Stdlib.output_char(oc, /* '(' */ 40);
      Stdlib__List.iter(loop, param._0);
      Stdlib.output_char(oc, /* ')' */ 41);
    };
    loop(sexp);
  };
  var Make_parser = function (Input) {
    var $great$great$eq = Input.Monad.bind;
    var $great$great$eq$star = function (m, f) {
      return Curry._2($great$great$eq, m, function (err) {
        if (err.TAG === /* Ok */ 0) {
          return Curry._1(f, err._0);
        } else {
          return Curry._1(Input.Monad.$$return, err);
        }
      });
    };
    var one_token = function (input, c, lexer, stack) {
      var exit = 0;
      var x;
      try {
        x = feed(lexer, c);
        exit = 1;
      } catch (raw_exn) {
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === Parse_error) {
          return Curry._1(Input.Monad.$$return, {
            TAG: /* Error */ 1,
            _0: exn._1,
          });
        }
        throw exn;
      }
      if (exit === 1) {
        if (typeof x !== "number") {
          return $great$great$eq$star(
            Curry._2(Input.read_string, input, x._0),
            function (s) {
              return Curry._1(Input.Monad.$$return, {
                TAG: /* Ok */ 0,
                _0: {
                  TAG: /* Sexp */ 1,
                  _0: {
                    TAG: /* Atom */ 0,
                    _0: s,
                  },
                  _1: stack,
                },
              });
            },
          );
        }
        var tmp;
        var exit$1 = 0;
        var stack$1;
        try {
          stack$1 = add_token(x, stack);
          exit$1 = 2;
        } catch (raw_exn$1) {
          var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
          if (exn$1.RE_EXN_ID === Parse_error) {
            tmp = {
              TAG: /* Error */ 1,
              _0: exn$1._1,
            };
          } else {
            throw exn$1;
          }
        }
        if (exit$1 === 2) {
          tmp = {
            TAG: /* Ok */ 0,
            _0: stack$1,
          };
        }
        return Curry._1(Input.Monad.$$return, tmp);
      }
    };
    var loop = function (input, lexer, stack) {
      return Curry._2(
        $great$great$eq,
        Curry._1(Input.read_char, input),
        function (param) {
          if (param.TAG === /* Ok */ 0) {
            return $great$great$eq$star(
              one_token(input, param._0, lexer, stack),
              function (stack) {
                if (
                  typeof stack === "number" ||
                  stack.TAG === /* Open */ 0 ||
                  typeof stack._1 !== "number"
                ) {
                  return loop(input, lexer, stack);
                } else {
                  return Curry._1(Input.Monad.$$return, {
                    TAG: /* Ok */ 0,
                    _0: stack._0,
                  });
                }
              },
            );
          } else {
            return Curry._1(
              Input.Monad.$$return,
              feed_eoi_single(lexer, stack),
            );
          }
        },
      );
    };
    var parse = function (input) {
      return loop(
        input,
        {
          state: /* Init */ 0,
          n: 0,
        },
        /* Empty */ 0,
      );
    };
    var loop$1 = function (input, lexer, stack) {
      return Curry._2(
        $great$great$eq,
        Curry._1(Input.read_char, input),
        function (param) {
          if (param.TAG === /* Ok */ 0) {
            return $great$great$eq$star(
              one_token(input, param._0, lexer, stack),
              function (stack) {
                return loop$1(input, lexer, stack);
              },
            );
          } else {
            return Curry._1(Input.Monad.$$return, feed_eoi_many(lexer, stack));
          }
        },
      );
    };
    var parse_many = function (input) {
      return loop$1(
        input,
        {
          state: /* Init */ 0,
          n: 0,
        },
        /* Empty */ 0,
      );
    };
    return {
      $great$great$eq: $great$great$eq,
      $great$great$eq$star: $great$great$eq$star,
      one_token: one_token,
      parse: parse,
      parse_many: parse_many,
    };
  };
  return {
    Parser: Parser,
    feed_eoi_single: feed_eoi_single,
    feed_eoi_many: feed_eoi_many,
    parse_string: parse_string,
    parse_string_many: parse_string_many,
    one_token: one_token,
    input_opt: input_opt,
    input: input,
    input_many: input_many,
    serialised_length: serialised_length,
    to_buffer: to_buffer,
    to_string: to_string,
    to_channel: to_channel,
    Make_parser: Make_parser,
  };
}

var T = {};

var Parse_error = /* @__PURE__ */ Caml_exceptions.create(
  "Test.Make(Sexp).Parser.Parse_error",
);

function parse_error(msg) {
  throw {
    RE_EXN_ID: Parse_error,
    _1: msg,
    Error: new Error(),
  };
}

function parse_errorf(f) {
  return Stdlib__Format.ksprintf(parse_error, f);
}

var premature_end_of_input = "premature end of input";

function create(param) {
  return {
    state: /* Init */ 0,
    n: 0,
  };
}

function int_of_digit(c) {
  return (c - /* '0' */ 48) | 0;
}

function feed(t, c) {
  var match = t.state;
  if (!match) {
    if (c === 41 || c === 40) {
      if (c >= 41) {
        return /* Rparen */ 2;
      } else {
        return /* Lparen */ 1;
      }
    } else if (c > 57 || c < 48) {
      return Curry._1(
        Stdlib__Format.ksprintf(
          parse_error,
          /* Format */ {
            _0: {
              TAG: /* String_literal */ 11,
              _0: "invalid character ",
              _1: {
                TAG: /* Caml_char */ 1,
                _0: {
                  TAG: /* String_literal */ 11,
                  _0: ", expected '(', ')' or '0'..'9'",
                  _1: /* End_of_format */ 0,
                },
              },
            },
            _1: "invalid character %C, expected '(', ')' or '0'..'9'",
          },
        ),
        c,
      );
    } else {
      t.state = /* Parsing_length */ 1;
      t.n = (c - /* '0' */ 48) | 0;
      return /* Await */ 0;
    }
  }
  if (c >= 58) {
    if (c >= 59) {
      return Curry._1(
        Stdlib__Format.ksprintf(
          parse_error,
          /* Format */ {
            _0: {
              TAG: /* String_literal */ 11,
              _0: "invalid character ",
              _1: {
                TAG: /* Caml_char */ 1,
                _0: {
                  TAG: /* String_literal */ 11,
                  _0: " while parsing atom length, expected '0'..'9' or ':'",
                  _1: /* End_of_format */ 0,
                },
              },
            },
            _1: "invalid character %C while parsing atom length, expected '0'..'9' or ':'",
          },
        ),
        c,
      );
    } else {
      t.state = /* Init */ 0;
      return /* Atom */ {
        _0: t.n,
      };
    }
  }
  if (c < 48) {
    return Curry._1(
      Stdlib__Format.ksprintf(
        parse_error,
        /* Format */ {
          _0: {
            TAG: /* String_literal */ 11,
            _0: "invalid character ",
            _1: {
              TAG: /* Caml_char */ 1,
              _0: {
                TAG: /* String_literal */ 11,
                _0: " while parsing atom length, expected '0'..'9' or ':'",
                _1: /* End_of_format */ 0,
              },
            },
          },
          _1: "invalid character %C while parsing atom length, expected '0'..'9' or ':'",
        },
      ),
      c,
    );
  }
  var len = (Math.imul(t.n, 10) + ((c - /* '0' */ 48) | 0)) | 0;
  if (len > Stdlib__Sys.max_string_length) {
    throw {
      RE_EXN_ID: Parse_error,
      _1: "atom too big to represent",
      Error: new Error(),
    };
  }
  t.n = len;
  return /* Await */ 0;
}

function feed_eoi(t) {
  var match = t.state;
  if (!match) {
    return;
  }
  throw {
    RE_EXN_ID: Parse_error,
    _1: premature_end_of_input,
    Error: new Error(),
  };
}

var Lexer = {
  create: create,
  int_of_digit: int_of_digit,
  feed: feed,
  feed_eoi: feed_eoi,
};

function open_paren(stack) {
  return {
    TAG: /* Open */ 0,
    _0: stack,
  };
}

function loop(_acc, _param) {
  while (true) {
    var param = _param;
    var acc = _acc;
    if (typeof param === "number") {
      throw {
        RE_EXN_ID: Parse_error,
        _1: "right parenthesis without matching left parenthesis",
        Error: new Error(),
      };
    }
    if (param.TAG === /* Open */ 0) {
      return {
        TAG: /* Sexp */ 1,
        _0: {
          TAG: /* List */ 1,
          _0: acc,
        },
        _1: param._0,
      };
    }
    _param = param._1;
    _acc = {
      hd: param._0,
      tl: acc,
    };
    continue;
  }
}

function close_paren(t) {
  return loop(/* [] */ 0, t);
}

function loop$1(_acc, _param) {
  while (true) {
    var param = _param;
    var acc = _acc;
    if (typeof param === "number") {
      return acc;
    }
    if (param.TAG === /* Open */ 0) {
      throw {
        RE_EXN_ID: Parse_error,
        _1: premature_end_of_input,
        Error: new Error(),
      };
    }
    _param = param._1;
    _acc = {
      hd: param._0,
      tl: acc,
    };
    continue;
  }
}

function to_list(t) {
  return loop$1(/* [] */ 0, t);
}

function add_atom(s, stack) {
  return {
    TAG: /* Sexp */ 1,
    _0: {
      TAG: /* Atom */ 0,
      _0: s,
    },
    _1: stack,
  };
}

function add_token(x, stack) {
  if (typeof x === "number") {
    switch (x) {
      case /* Await */ 0:
        return stack;
      case /* Lparen */ 1:
        return {
          TAG: /* Open */ 0,
          _0: stack,
        };
      case /* Rparen */ 2:
        return loop(/* [] */ 0, stack);
    }
  }
}

var Stack = {
  open_paren: open_paren,
  close_paren: close_paren,
  to_list: to_list,
  add_atom: add_atom,
  add_token: add_token,
};

var Parser = {
  Parse_error: Parse_error,
  parse_error: parse_error,
  parse_errorf: parse_errorf,
  premature_end_of_input: premature_end_of_input,
  Lexer: Lexer,
  Stack: Stack,
};

function feed_eoi_single(lexer, stack) {
  var val;
  try {
    feed_eoi(lexer);
    val = loop$1(/* [] */ 0, stack);
  } catch (raw_exn) {
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Parse_error) {
      return {
        TAG: /* Error */ 1,
        _0: exn._1,
      };
    }
    throw exn;
  }
  if (!val) {
    return {
      TAG: /* Error */ 1,
      _0: premature_end_of_input,
    };
  }
  if (val.tl) {
    throw {
      RE_EXN_ID: "Assert_failure",
      _1: ["", 213, 21],
      Error: new Error(),
    };
  }
  return {
    TAG: /* Ok */ 0,
    _0: val.hd,
  };
}

function feed_eoi_many(lexer, stack) {
  var l;
  try {
    feed_eoi(lexer);
    l = loop$1(/* [] */ 0, stack);
  } catch (raw_exn) {
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Parse_error) {
      return {
        TAG: /* Error */ 1,
        _0: exn._1,
      };
    }
    throw exn;
  }
  return {
    TAG: /* Ok */ 0,
    _0: l,
  };
}

function loop$2(s, pos, len, lexer, stack) {
  if (pos === len) {
    var msg = feed_eoi_single(lexer, stack);
    if (msg.TAG === /* Ok */ 0) {
      return msg;
    } else {
      return {
        TAG: /* Error */ 1,
        _0: [pos, msg._0],
      };
    }
  }
  var exit = 0;
  var x;
  try {
    x = feed(lexer, s.charCodeAt(pos));
    exit = 1;
  } catch (raw_exn) {
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Parse_error) {
      return {
        TAG: /* Error */ 1,
        _0: [pos, exn._1],
      };
    }
    throw exn;
  }
  if (exit === 1) {
    if (typeof x === "number") {
      var exit$1 = 0;
      var stack$1;
      try {
        stack$1 = add_token(x, stack);
        exit$1 = 2;
      } catch (raw_exn$1) {
        var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
        if (exn$1.RE_EXN_ID === Parse_error) {
          return {
            TAG: /* Error */ 1,
            _0: [pos, exn$1._1],
          };
        }
        throw exn$1;
      }
      if (exit$1 === 2) {
        return cont(s, (pos + 1) | 0, len, lexer, stack$1);
      }
    } else {
      var atom_len = x._0;
      var exit$2 = 0;
      var atom;
      try {
        atom = Stdlib__String.sub(s, (pos + 1) | 0, atom_len);
        exit$2 = 2;
      } catch (exn$2) {
        return {
          TAG: /* Error */ 1,
          _0: [len, premature_end_of_input],
        };
      }
      if (exit$2 === 2) {
        var pos$1 = (((pos + 1) | 0) + atom_len) | 0;
        return cont(s, pos$1, len, lexer, {
          TAG: /* Sexp */ 1,
          _0: {
            TAG: /* Atom */ 0,
            _0: atom,
          },
          _1: stack,
        });
      }
    }
  }
}

function cont(s, pos, len, lexer, stack) {
  if (
    typeof stack !== "number" &&
    stack.TAG !== /* Open */ 0 &&
    typeof stack._1 === "number"
  ) {
    if (pos === len) {
      return {
        TAG: /* Ok */ 0,
        _0: stack._0,
      };
    } else {
      return {
        TAG: /* Error */ 1,
        _0: [pos, "data after canonical S-expression"],
      };
    }
  }
  return loop$2(s, pos, len, lexer, stack);
}

function parse_string(s) {
  return loop$2(
    s,
    0,
    s.length,
    {
      state: /* Init */ 0,
      n: 0,
    },
    /* Empty */ 0,
  );
}

function parse_string_many(s) {
  var _pos = 0;
  var len = s.length;
  var lexer = {
    state: /* Init */ 0,
    n: 0,
  };
  var _stack = /* Empty */ 0;
  while (true) {
    var stack = _stack;
    var pos = _pos;
    if (pos === len) {
      var msg = feed_eoi_many(lexer, stack);
      if (msg.TAG === /* Ok */ 0) {
        return msg;
      } else {
        return {
          TAG: /* Error */ 1,
          _0: [pos, msg._0],
        };
      }
    }
    var exit = 0;
    var x;
    try {
      x = feed(lexer, s.charCodeAt(pos));
      exit = 1;
    } catch (raw_exn) {
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Parse_error) {
        return {
          TAG: /* Error */ 1,
          _0: [pos, exn._1],
        };
      }
      throw exn;
    }
    if (exit === 1) {
      if (typeof x === "number") {
        var exit$1 = 0;
        var stack$1;
        try {
          stack$1 = add_token(x, stack);
          exit$1 = 2;
        } catch (raw_exn$1) {
          var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
          if (exn$1.RE_EXN_ID === Parse_error) {
            return {
              TAG: /* Error */ 1,
              _0: [pos, exn$1._1],
            };
          }
          throw exn$1;
        }
        if (exit$1 === 2) {
          _stack = stack$1;
          _pos = (pos + 1) | 0;
          continue;
        }
      } else {
        var atom_len = x._0;
        var exit$2 = 0;
        var atom;
        try {
          atom = Stdlib__String.sub(s, (pos + 1) | 0, atom_len);
          exit$2 = 2;
        } catch (exn$2) {
          return {
            TAG: /* Error */ 1,
            _0: [len, premature_end_of_input],
          };
        }
        if (exit$2 === 2) {
          var pos$1 = (((pos + 1) | 0) + atom_len) | 0;
          _stack = {
            TAG: /* Sexp */ 1,
            _0: {
              TAG: /* Atom */ 0,
              _0: atom,
            },
            _1: stack,
          };
          _pos = pos$1;
          continue;
        }
      }
    }
  }
}

function one_token(ic, c, lexer, stack) {
  var n = feed(lexer, c);
  if (typeof n === "number") {
    return add_token(n, stack);
  }
  var s;
  try {
    s = Stdlib.really_input_string(ic, n._0);
  } catch (raw_exn) {
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib.End_of_file) {
      throw {
        RE_EXN_ID: Parse_error,
        _1: premature_end_of_input,
        Error: new Error(),
      };
    }
    throw exn;
  }
  return {
    TAG: /* Sexp */ 1,
    _0: {
      TAG: /* Atom */ 0,
      _0: s,
    },
    _1: stack,
  };
}

function input_opt(ic) {
  var lexer = {
    state: /* Init */ 0,
    n: 0,
  };
  var c;
  try {
    c = Stdlib.input_char(ic);
  } catch (raw_exn) {
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib.End_of_file) {
      return {
        TAG: /* Ok */ 0,
        _0: undefined,
      };
    }
    throw exn;
  }
  try {
    var x = feed(lexer, c);
    if (typeof x === "number") {
      var _stack = add_token(x, /* Empty */ 0);
      while (true) {
        var stack = _stack;
        var c$1 = Stdlib.input_char(ic);
        var stack$1 = one_token(ic, c$1, lexer, stack);
        if (typeof stack$1 === "number") {
          _stack = stack$1;
          continue;
        }
        if (stack$1.TAG === /* Open */ 0) {
          _stack = stack$1;
          continue;
        }
        if (typeof stack$1._1 === "number") {
          return {
            TAG: /* Ok */ 0,
            _0: stack$1._0,
          };
        }
        _stack = stack$1;
        continue;
      }
    }
    throw {
      RE_EXN_ID: "Assert_failure",
      _1: ["", 286, 24],
      Error: new Error(),
    };
  } catch (raw_exn$1) {
    var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    if (exn$1.RE_EXN_ID === Parse_error) {
      return {
        TAG: /* Error */ 1,
        _0: exn$1._1,
      };
    }
    if (exn$1.RE_EXN_ID === Stdlib.End_of_file) {
      return {
        TAG: /* Error */ 1,
        _0: premature_end_of_input,
      };
    }
    throw exn$1;
  }
}

function input(ic) {
  var msg = input_opt(ic);
  if (msg.TAG !== /* Ok */ 0) {
    return {
      TAG: /* Error */ 1,
      _0: msg._0,
    };
  }
  var x = msg._0;
  if (x !== undefined) {
    return {
      TAG: /* Ok */ 0,
      _0: x,
    };
  } else {
    return {
      TAG: /* Error */ 1,
      _0: premature_end_of_input,
    };
  }
}

function input_many(ic) {
  try {
    var lexer = {
      state: /* Init */ 0,
      n: 0,
    };
    var _stack = /* Empty */ 0;
    while (true) {
      var stack = _stack;
      var c;
      try {
        c = Stdlib.input_char(ic);
      } catch (raw_exn) {
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === Stdlib.End_of_file) {
          feed_eoi(lexer);
          return {
            TAG: /* Ok */ 0,
            _0: loop$1(/* [] */ 0, stack),
          };
        }
        throw exn;
      }
      _stack = one_token(ic, c, lexer, stack);
      continue;
    }
  } catch (raw_exn$1) {
    var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    if (exn$1.RE_EXN_ID === Parse_error) {
      return {
        TAG: /* Error */ 1,
        _0: exn$1._1,
      };
    }
    throw exn$1;
  }
}

function loop$3(acc, t) {
  if (t.TAG !== /* Atom */ 0) {
    return (2 + Stdlib__List.fold_left(loop$3, acc, t._0)) | 0;
  }
  var len = t._0.length;
  var x = len;
  var len_len = 1;
  while (x > 9) {
    x = (x / 10) | 0;
    len_len = (len_len + 1) | 0;
  }
  return (((((acc + len_len) | 0) + 1) | 0) + len) | 0;
}

function serialised_length(t) {
  return loop$3(0, t);
}

function to_buffer(buf, sexp) {
  var loop = function (param) {
    if (param.TAG === /* Atom */ 0) {
      var str = param._0;
      Stdlib__Buffer.add_string(buf, String(str.length));
      Stdlib__Buffer.add_string(buf, ":");
      return Stdlib__Buffer.add_string(buf, str);
    }
    Stdlib__Buffer.add_char(buf, /* '(' */ 40);
    Stdlib__List.iter(loop, param._0);
    Stdlib__Buffer.add_char(buf, /* ')' */ 41);
  };
  loop(sexp);
}

function to_string(sexp) {
  var buf = Stdlib__Buffer.create(loop$3(0, sexp));
  to_buffer(buf, sexp);
  return Stdlib__Buffer.contents(buf);
}

function to_channel(oc, sexp) {
  var loop = function (param) {
    if (param.TAG === /* Atom */ 0) {
      var str = param._0;
      Stdlib.output_string(oc, String(str.length));
      Stdlib.output_char(oc, /* ':' */ 58);
      return Stdlib.output_string(oc, str);
    }
    Stdlib.output_char(oc, /* '(' */ 40);
    Stdlib__List.iter(loop, param._0);
    Stdlib.output_char(oc, /* ')' */ 41);
  };
  loop(sexp);
}

function Make_parser(Input) {
  var $great$great$eq = Input.Monad.bind;
  var $great$great$eq$star = function (m, f) {
    return Curry._2($great$great$eq, m, function (err) {
      if (err.TAG === /* Ok */ 0) {
        return Curry._1(f, err._0);
      } else {
        return Curry._1(Input.Monad.$$return, err);
      }
    });
  };
  var one_token = function (input, c, lexer, stack) {
    var exit = 0;
    var x;
    try {
      x = feed(lexer, c);
      exit = 1;
    } catch (raw_exn) {
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Parse_error) {
        return Curry._1(Input.Monad.$$return, {
          TAG: /* Error */ 1,
          _0: exn._1,
        });
      }
      throw exn;
    }
    if (exit === 1) {
      if (typeof x !== "number") {
        return $great$great$eq$star(
          Curry._2(Input.read_string, input, x._0),
          function (s) {
            return Curry._1(Input.Monad.$$return, {
              TAG: /* Ok */ 0,
              _0: {
                TAG: /* Sexp */ 1,
                _0: {
                  TAG: /* Atom */ 0,
                  _0: s,
                },
                _1: stack,
              },
            });
          },
        );
      }
      var tmp;
      var exit$1 = 0;
      var stack$1;
      try {
        stack$1 = add_token(x, stack);
        exit$1 = 2;
      } catch (raw_exn$1) {
        var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
        if (exn$1.RE_EXN_ID === Parse_error) {
          tmp = {
            TAG: /* Error */ 1,
            _0: exn$1._1,
          };
        } else {
          throw exn$1;
        }
      }
      if (exit$1 === 2) {
        tmp = {
          TAG: /* Ok */ 0,
          _0: stack$1,
        };
      }
      return Curry._1(Input.Monad.$$return, tmp);
    }
  };
  var loop = function (input, lexer, stack) {
    return Curry._2(
      $great$great$eq,
      Curry._1(Input.read_char, input),
      function (param) {
        if (param.TAG === /* Ok */ 0) {
          return $great$great$eq$star(
            one_token(input, param._0, lexer, stack),
            function (stack) {
              if (
                typeof stack === "number" ||
                stack.TAG === /* Open */ 0 ||
                typeof stack._1 !== "number"
              ) {
                return loop(input, lexer, stack);
              } else {
                return Curry._1(Input.Monad.$$return, {
                  TAG: /* Ok */ 0,
                  _0: stack._0,
                });
              }
            },
          );
        } else {
          return Curry._1(Input.Monad.$$return, feed_eoi_single(lexer, stack));
        }
      },
    );
  };
  var parse = function (input) {
    return loop(
      input,
      {
        state: /* Init */ 0,
        n: 0,
      },
      /* Empty */ 0,
    );
  };
  var loop$1 = function (input, lexer, stack) {
    return Curry._2(
      $great$great$eq,
      Curry._1(Input.read_char, input),
      function (param) {
        if (param.TAG === /* Ok */ 0) {
          return $great$great$eq$star(
            one_token(input, param._0, lexer, stack),
            function (stack) {
              return loop$1(input, lexer, stack);
            },
          );
        } else {
          return Curry._1(Input.Monad.$$return, feed_eoi_many(lexer, stack));
        }
      },
    );
  };
  var parse_many = function (input) {
    return loop$1(
      input,
      {
        state: /* Init */ 0,
        n: 0,
      },
      /* Empty */ 0,
    );
  };
  return {
    $great$great$eq: $great$great$eq,
    $great$great$eq$star: $great$great$eq$star,
    one_token: one_token,
    parse: parse,
    parse_many: parse_many,
  };
}

export {
  Make,
  T,
  Parser,
  feed_eoi_single,
  feed_eoi_many,
  parse_string,
  parse_string_many,
  one_token,
  input_opt,
  input,
  input_many,
  serialised_length,
  to_buffer,
  to_string,
  to_channel,
  Make_parser,
};
/* Stdlib__Format Not a pure module */
